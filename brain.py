#!/usr/bin/env python3
"""
Trading Bot Brain Module
Contains the LLM integration and decision-making logic for the trading bot
"""

import os
import json
import logging
import datetime
import pandas as pd
import numpy as np
import openai
import requests
from typing import Dict, List, Any, Optional, Tuple, Union

# Configure logging
logger = logging.getLogger("Trading_Brain")

# --- LLM Generated Strategy ---
class LLMGeneratedStrategy:
    """Strategy dynamically generated by LLM with parameters"""
    
    def __init__(self, name="LLM Generated Strategy", parameters=None, strategy_code=None):
        """Initialize with strategy parameters and executable code"""
        super().__init__()
        self.name = name
        
        # Set default parameters
        self.parameters = parameters or {}
        
        # Store strategy code
        self.strategy_code = strategy_code or """
def generate_signals(self, data):
    # Default implementation - SMA Crossover
    if data.empty:
        return data
    
    # Make a copy to avoid modifying the original
    df = data.copy()
    
    # Calculate fast and slow SMAs
    fast_period = self.parameters.get('fast_period', 10)
    slow_period = self.parameters.get('slow_period', 30)
    
    df['fast_ma'] = df['close'].rolling(window=fast_period).mean()
    df['slow_ma'] = df['close'].rolling(window=slow_period).mean()
    
    # Initialize signal column
    df['signal'] = 0
    
    # Calculate crossover signals
    df['prev_fast_ma'] = df['fast_ma'].shift(1)
    df['prev_slow_ma'] = df['slow_ma'].shift(1)
    
    # Buy signal: fast MA crosses above slow MA
    buy_condition = (df['prev_fast_ma'] < df['prev_slow_ma']) & (df['fast_ma'] > df['slow_ma'])
    df.loc[buy_condition, 'signal'] = 1
    
    # Sell signal: fast MA crosses below slow MA
    sell_condition = (df['prev_fast_ma'] > df['prev_slow_ma']) & (df['fast_ma'] < df['slow_ma'])
    df.loc[sell_condition, 'signal'] = -1
    
    return df
"""
        
        # Create the function dynamically
        self._create_dynamic_method()
    
    def _create_dynamic_method(self):
        """Create generate_signals method dynamically from code string"""
        try:
            # Create a local namespace
            local_namespace = {}
            
            # Execute the code in the local namespace
            exec(self.strategy_code, globals(), local_namespace)
            
            # Bind the function to the instance
            self.generate_signals_impl = local_namespace.get('generate_signals')
            
            if not self.generate_signals_impl:
                logger.error("Strategy code did not define a generate_signals function")
                # Set default implementation
                self.generate_signals_impl = lambda self, data: data
                
        except Exception as e:
            logger.error(f"Error creating dynamic method: {str(e)}")
            # Set default implementation
            self.generate_signals_impl = lambda self, data: data
    
    def generate_signals(self, data):
        """Generate trading signals using dynamically created method"""
        try:
            # Call the dynamically created implementation
            return self.generate_signals_impl(self, data)
        except Exception as e:
            logger.error(f"Error in dynamic strategy: {str(e)}")
            # Return original data if there's an error
            return data
    
    def calculate_stop_loss(self, data, signal_row_idx, direction):
        """Calculate stop loss based on recent price action"""
        # Look back for recent swing points
        lookback = min(20, signal_row_idx)
        recent_data = data.iloc[signal_row_idx-lookback:signal_row_idx+1]
        
        if direction == "BUY":
            # For buy signals, set stop below recent low
            stop_price = recent_data['low'].min() * 0.998  # Slightly below the low
        else:
            # For sell signals, set stop above recent high
            stop_price = recent_data['high'].max() * 1.002  # Slightly above the high
            
        return stop_price
    
    def calculate_take_profit(self, data, signal_row_idx, direction):
        """Calculate take profit based on stop loss distance"""
        # Set take profit at 2:1 risk-reward ratio
        entry_price = data.iloc[signal_row_idx]['close']
        stop_loss = self.calculate_stop_loss(data, signal_row_idx, direction)
        
        if direction == "BUY":
            risk = entry_price - stop_loss
            take_profit = entry_price + (risk * 2)
        else:
            risk = stop_loss - entry_price
            take_profit = entry_price - (risk * 2)
            
        return take_profit
    
    def get_parameters(self):
        """Get current parameters"""
        return self.parameters.copy()
    
    def set_parameters(self, **kwargs):
        """Update strategy parameters"""
        self.parameters.update(kwargs)
    
    def save_to_file(self, filename=None):
        """Save strategy to file for later reuse"""
        if filename is None:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_name = self.name.replace(" ", "_").lower()
            filename = f"strategies/{safe_name}_{timestamp}.json"
        
        os.makedirs(os.path.dirname(filename), exist_ok=True)
        
        strategy_data = {
            "name": self.name,
            "parameters": self.parameters,
            "strategy_code": self.strategy_code
        }
        
        with open(filename, 'w') as f:
            json.dump(strategy_data, f, indent=2)
        
        logger.info(f"Strategy saved to {filename}")
        return filename
    
    @staticmethod
    def load_from_file(filename):
        """Load strategy from file"""
        with open(filename, 'r') as f:
            strategy_data = json.load(f)
        
        return LLMGeneratedStrategy(
            name=strategy_data.get("name", "Loaded Strategy"),
            parameters=strategy_data.get("parameters", {}),
            strategy_code=strategy_data.get("strategy_code", "")
        )

# --- Memory System ---
class TradingMemory:
    """Maintains trading history and system state"""
    
    def __init__(self):
        """Initialize trading memory"""
        self.memory_file = "data/system_memory.json"
        self.trade_log_file = "data/trade_log.jsonl"
        self.review_log_file = "data/review_log.jsonl"
        self.strategies_dir = "strategies"
        
        # Ensure data directories exist
        os.makedirs("data", exist_ok=True)
        os.makedirs(self.strategies_dir, exist_ok=True)
        
        # Initialize or load system memory
        self.load_memory()
    
    def load_memory(self):
        """Load or initialize system memory"""
        if os.path.exists(self.memory_file):
            try:
                with open(self.memory_file, "r") as f:
                    self.memory = json.load(f)
            except:
                self.initialize_memory()
        else:
            self.initialize_memory()
    
    def initialize_memory(self):
        """Create initial memory structure"""
        from bot import INITIAL_SAFETY_LEVEL
        
        self.memory = {
            "created": datetime.datetime.now().isoformat(),
            "last_updated": datetime.datetime.now().isoformat(),
            "trade_count": 0,
            "win_count": 0,
            "loss_count": 0,
            "safety_level": INITIAL_SAFETY_LEVEL,
            "daily_drawdown": 0.0,
            "daily_profit": 0.0,
            "daily_profit_pct": 0.0,
            "daily_high_balance": 0.0,
            "daily_starting_balance": 0.0,
            "total_risk_committed": 0.0,
            "prompt_versions": [],
            "strategy_weights": {
                "trend_following": 1.0,
                "breakout": 1.0,
                "mean_reversion": 1.0
            },
            "saved_strategies": []
        }
        self.save_memory()
    
    def save_memory(self):
        """Save system memory to disk"""
        self.memory["last_updated"] = datetime.datetime.now().isoformat()
        with open(self.memory_file, "w") as f:
            json.dump(self.memory, f, indent=2)
    
    def log_trade(self, trade_data):
        """Log a trade to the trade history"""
        from bot import INCREASE_FACTOR
        
        # Update trade count
        self.memory["trade_count"] += 1
        
        # Update win/loss stats if applicable
        if trade_data.get("is_win"):
            self.memory["win_count"] += 1
            # Increase safety level after win
            self.memory["safety_level"] = min(0.05, self.memory["safety_level"] + INCREASE_FACTOR)
        elif trade_data.get("is_loss"):
            self.memory["loss_count"] += 1
        
        # Add timestamp if not provided
        if "timestamp" not in trade_data:
            trade_data["timestamp"] = datetime.datetime.now().isoformat()
        
        # Append to trade log
        with open(self.trade_log_file, "a") as f:
            f.write(json.dumps(trade_data) + "\n")
        
        # Save updated memory
        self.save_memory()
    
    def log_review(self, review_data):
        """Log a system review"""
        # Save the new prompt version if provided
        if "prompt_version" in review_data:
            self.memory["prompt_versions"].append({
                "timestamp": datetime.datetime.now().isoformat(),
                "content": review_data["prompt_version"],
                "reason": review_data.get("reason", "Regular review")
            })
        
        # Update strategy weights if provided
        if "strategy_weights" in review_data:
            self.memory["strategy_weights"] = review_data["strategy_weights"]
        
        # Append to review log
        with open(self.review_log_file, "a") as f:
            f.write(json.dumps(review_data) + "\n")
        
        # Save updated memory
        self.save_memory()
    
    def log_strategy(self, strategy):
        """Save a successful strategy to memory"""
        # Save strategy to file
        filename = strategy.save_to_file()
        
        # Add to memory
        if "saved_strategies" not in self.memory:
            self.memory["saved_strategies"] = []
            
        self.memory["saved_strategies"].append({
            "name": strategy.name,
            "timestamp": datetime.datetime.now().isoformat(),
            "filename": filename,
            "parameters": strategy.parameters
        })
        
        # Save updated memory
        self.save_memory()
    
    def get_recent_trades(self, limit=10):
        """Get recent trades from log"""
        trades = []
        try:
            if os.path.exists(self.trade_log_file):
                with open(self.trade_log_file, "r") as f:
                    for line in f:
                        trades.append(json.loads(line))
                
                # Sort by timestamp (newest first) and limit
                trades.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
                return trades[:limit]
        except Exception as e:
            logger.error(f"Error getting recent trades: {e}")
        
        return trades
    
    def reset_daily_stats(self, account_balance):
        """Reset daily statistics"""
        self.memory["daily_drawdown"] = 0.0
        self.memory["daily_profit"] = 0.0
        self.memory["daily_profit_pct"] = 0.0
        self.memory["daily_high_balance"] = account_balance
        self.memory["daily_starting_balance"] = account_balance
        self.memory["total_risk_committed"] = 0.0
        self.save_memory()
    
    def get_saved_strategies(self, limit=5):
        """Get the most recent saved strategies"""
        if "saved_strategies" not in self.memory:
            return []
            
        strategies = self.memory["saved_strategies"]
        strategies.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
        return strategies[:limit]
    
    def load_strategy(self, strategy_name=None, strategy_file=None):
        """Load a strategy from memory or file"""
        if strategy_file:
            return LLMGeneratedStrategy.load_from_file(strategy_file)
        
        if strategy_name:
            strategies = self.memory.get("saved_strategies", [])
            for strategy in strategies:
                if strategy.get("name") == strategy_name and os.path.exists(strategy.get("filename", "")):
                    return LLMGeneratedStrategy.load_from_file(strategy.get("filename"))
        
        # Return most recent if not found
        strategies = self.get_saved_strategies(1)
        if strategies:
            strategy = strategies[0]
            if os.path.exists(strategy.get("filename", "")):
                return LLMGeneratedStrategy.load_from_file(strategy.get("filename"))
        
        # Return default if no saved strategies
        return LLMGeneratedStrategy()

# --- LLM Trading Brain ---
class LLMTradingBrain:
    """LLM-powered trading decision maker with self-improvement capabilities"""
    
    def __init__(self, memory, backtester):
        """Initialize the LLM trading brain"""
        self.memory = memory
        self.backtester = backtester
        
        # Get API key from environment
        from bot import OPENAI_API_KEY
        openai.api_key = OPENAI_API_KEY
        
        # Initial system prompt (will be evolved over time)
        self.system_prompt = """
You are a self-evolving forex trading AI specializing in EUR/USD.

Your goal is to achieve a 5% daily return while respecting strict risk management:
- Maximum account risk: 10%
- Maximum daily drawdown: 10%
- Implement trailing stops and profit taking

Your decisions should be based on:
1. Technical analysis of EUR/USD price action
2. Analysis of past trades (what worked and what didn't)
3. Backtesting validation of strategies before trading
4. Risk management based on account's current exposure

Always provide a clear trade plan with:
- Direction (BUY/SELL)
- Entry price and acceptable range
- Stop loss level (must be specified)
- Take profit targets (multiple levels recommended)
- Risk percentage (1-5% based on conviction)
- Position sizing logic
- Technical justification

Consider using these strategies based on market conditions:
- Trend following: Identify and follow established trends
- Breakout: Capture price moves from established ranges
- Mean reversion: Trade returns to mean after extreme movements

Your memory and self-improvement:
- Learn from successful and unsuccessful trades
- Adapt your approach based on recent performance
- Evolve your strategies over time for better results
- Create and backtest new strategies before deployment
"""
        
    def analyze_market(self, price_data, account_data, positions, market_data=None):
        """Analyze market data and generate trading signals"""
        try:
            # Default response if analysis fails
            default_action = {"action": "WAIT", "reason": "Analysis failed or insufficient data"}
            
            if price_data.empty:
                logger.warning("Empty price data provided for analysis")
                return default_action
            
            # Prepare memory metrics
            memory_stats = {
                "balance": account_data.get("balance", 0),
                "currency": "USD",
                "safety_level": self.memory.memory.get("safety_level", 0.01),
                "daily_profit_pct": account_data.get("daily_profit_pct", 0),
                "win_rate": (self.memory.memory.get("win_count", 0) / self.memory.memory.get("trade_count", 1)) * 100 if self.memory.memory.get("trade_count", 0) > 0 else 0,
                "win_count": self.memory.memory.get("win_count", 0),
                "trade_count": self.memory.memory.get("trade_count", 0)
            }
            
            # Get recent trades
            recent_trades = self.memory.get_recent_trades(5)
            
            # Format recent trades for prompt
            recent_trades_formatted = []
            for trade in recent_trades:
                trade_str = f"Direction: {trade.get('direction', 'Unknown')}, "
                trade_str += f"Entry: {trade.get('entry_price', 'Unknown')}, "
                trade_str += f"Exit: {trade.get('exit_price', 'Unknown') if trade.get('exit_price') else 'Open'}, "
                trade_str += f"Result: {'Win' if trade.get('is_win') else 'Loss' if trade.get('is_loss') else 'Unknown/Open'}, "
                trade_str += f"Reasoning: {trade.get('reasoning', 'None provided')[:100]}..."
                recent_trades_formatted.append(trade_str)
            
            # Format open positions
            open_positions = "None" if not positions else ", ".join([
                f"ID: {p.get('id', 'Unknown')}, Direction: {'BUY' if int(p.get('long', {}).get('units', 0)) > 0 else 'SELL'}, "
                f"Units: {abs(int(p.get('long', {}).get('units', 0)) or int(p.get('short', {}).get('units', 0)))}, "
                f"Unrealized P&L: {p.get('unrealizedPL', 'Unknown')}"
                for p in positions if p.get('instrument') == 'EUR_USD'
            ])
            
            # Format price data (just a sample)
            price_sample = price_data.tail(5).to_string()
            
            # Format market data
            technical_data = "Not available"
            if market_data and "technical_indicators" in market_data:
                technical_data = str(market_data["technical_indicators"])
            
            multi_tf_data = "Not available"
            if market_data and "multi_timeframe" in market_data:
                multi_tf_data = "Available across timeframes"
            
            intermarket_data = "Not available"
            if market_data and "intermarket" in market_data:
                intermarket_data = str(market_data["intermarket"])
            
            econ_data = "Not available"
            if market_data and "economic" in market_data:
                econ_data = str(market_data["economic"])
            
            sentiment_data = "Not available"
            if market_data and "sentiment" in market_data:
                sentiment_data = str(market_data["sentiment"])
            
            # Get saved strategies
            strategies = self.memory.get_saved_strategies(3)
            strategy_info = "None" if not strategies else ", ".join([f"{s.get('name', 'Unknown')}" for s in strategies])
            
            # Create a simplified prompt to test API functionality
            simple_prompt = f"""
            Please analyze the following trading data and provide a decision on EUR/USD:

            Current price: {price_data['close'].iloc[-1]}
            Account balance: {memory_stats["balance"]}
            Current positions: {open_positions}

            Respond with a JSON object containing:
            {{
              "action": "OPEN" or "WAIT",
              "trade_details": {{
                "direction": "BUY" or "SELL",
                "entry_price": price,
                "stop_loss": sl_price,
                "take_profit": [tp_level1, tp_level2],
                "risk_percent": 1-5 based on conviction,
                "reasoning": "brief explanation"
              }}
            }}
            """
            
            # Call OpenAI API using a simpler approach
            try:
                # Import the OpenAI client directly
                from openai import OpenAI
                
                # Initialize client
                client = OpenAI(api_key=openai.api_key)
                
                # Log that we're about to make the API call
                logger.info("Calling OpenAI API with simplified prompt...")
                
                # Make the API call
                response = client.chat.completions.create(
                    model="gpt-4-turbo",
                    messages=[
                        {"role": "system", "content": "You are a trading assistant that responds only in JSON format."},
                        {"role": "user", "content": simple_prompt}
                    ],
                    temperature=0.7,
                    max_tokens=1000
                )
                
                # Extract the response text
                decision_text = response.choices[0].message.content
                
                # Log the first part of the response for diagnostic purposes
                logger.info(f"Raw LLM response (first 200 chars): {decision_text[:200]}...")
                
                # Parse the JSON response
                try:
                    decision_json = json.loads(decision_text)
                    
                    # Extract the action field or set default
                    action = decision_json.get("action", "WAIT")
                    if not action:
                        action = "WAIT"
                    
                    # Ensure action is in the result
                    decision_json["action"] = action
                    
                    # Add raw LLM response for debugging
                    decision_json["raw_llm_response"] = decision_text
                    
                    return decision_json
                    
                except json.JSONDecodeError as e:
                    logger.warning(f"JSON parsing failed: {e}")
                    
                    # Fallback with more robust extraction
                    json_str = self._extract_json_from_text(decision_text)
                    if json_str:
                        return json.loads(json_str)
                    else:
                        # If all parsing fails, extract action from text
                        if "BUY" in decision_text:
                            return {
                                "action": "OPEN",
                                "trade_details": {
                                    "direction": "BUY",
                                    "reasoning": "Extracted from non-JSON response"
                                }
                            }
                        elif "SELL" in decision_text:
                            return {
                                "action": "OPEN", 
                                "trade_details": {
                                    "direction": "SELL",
                                    "reasoning": "Extracted from non-JSON response"
                                }
                            }
                        else:
                            return {"action": "WAIT", "reason": "Could not parse response as JSON"}
                    
            except Exception as e:
                logger.error(f"Error calling OpenAI API: {str(e)}")
                return {"action": "WAIT", "reason": f"OpenAI API error: {str(e)}"}
                
        except Exception as e:
            logger.error(f"Error analyzing market: {e}")
            return {"action": "WAIT", "reason": f"Analysis error: {str(e)}"}
    
    def _extract_json_from_text(self, text):
        """Extract and fix JSON from text that might contain incomplete JSON"""
        try:
            # Find the JSON-like part (starting with { and ending with })
            json_pattern = re.compile(r'(\{.*\})', re.DOTALL)
            match = json_pattern.search(text)
            
            if not match:
                return None
            
            json_str = match.group(1)
            
            # Clean up common JSON formatting issues
            json_str = re.sub(r',\s*}', '}', json_str)  # Remove trailing commas
            json_str = re.sub(r',\s*]', ']', json_str)  # Remove trailing commas in arrays
            
            try:
                return json.loads(json_str)
            except json.JSONDecodeError as e:
                logger.warning(f"JSON parsing failed after cleanup: {e}")
                
                # Try additional cleanup for more severe formatting issues
                # Remove any newlines and extra spaces before quotes
                json_str = re.sub(r'\n\s*"', '"', json_str)
                # Ensure proper property name formatting
                json_str = re.sub(r'([{,])\s*([^"\s]+)\s*:', r'\1"\2":', json_str)
                
                return json.loads(json_str)
        except Exception as e:
            logger.error(f"Error in JSON extraction: {e}")
            return None
    
    def validate_trade(self, trade_details, price_data, validation_period=10):
        """Validate a trade through backtesting before execution"""
        try:
            # Extract strategy details
            strategy_type = trade_details.get("strategy", "trend_following")
            direction = trade_details.get("direction", "BUY").upper()
            entry_price = float(trade_details.get("entry_price", 0))
            stop_loss = float(trade_details.get("stop_loss", 0))
            risk_percent = float(trade_details.get("risk_percent", 2.0)) if trade_details.get("risk_percent") else 2.0
            
            # Default validation result
            valid = False
            confidence = 0.0
            reason = "Failed validation checks"
            
            # Basic validation checks
            if entry_price <= 0 or stop_loss <= 0:
                return {"valid": False, "confidence": 0.0, "reason": "Invalid prices"}
                
            if risk_percent <= 0 or risk_percent > 5:
                return {"valid": False, "confidence": 0.0, "reason": "Invalid risk percentage"}
                
            # Calculate risk-reward ratio
            take_profit_levels = trade_details.get("take_profit", [])
            if not take_profit_levels:
                return {"valid": False, "confidence": 0.0, "reason": "No take profit levels provided"}
                
            # Use first take profit level for calculation
            first_tp = float(take_profit_levels[0]) if isinstance(take_profit_levels, list) else float(take_profit_levels)
            
            # Calculate risk and reward
            if direction == "BUY":
                risk = entry_price - stop_loss
                reward = first_tp - entry_price
            else:  # SELL
                risk = stop_loss - entry_price
                reward = entry_price - first_tp
            
            # Validate risk-reward ratio
            risk_reward_ratio = reward / risk if risk > 0 else 0
            if risk_reward_ratio < 1.5:
                return {"valid": False, "confidence": 0.0, "reason": f"Poor risk-reward ratio: {risk_reward_ratio:.2f}"}
                
            # Load or create strategy for backtest
            strategy = None
            from bot import MIN_CONFIDENCE_THRESHOLD
            
            try:
                # Check if there's a matching saved strategy
                saved_strategies = self.memory.get_saved_strategies()
                for saved in saved_strategies:
                    if saved.get("name", "").lower().startswith(strategy_type.lower()):
                        strategy = self.memory.load_strategy(strategy_name=saved.get("name"))
                        break
                
                # Create a simple strategy for validation if none found
                if not strategy:
                    strategy = self._create_validation_strategy(strategy_type, entry_price, stop_loss, direction)
            
                # Run backtests to validate the strategy
                end_date = datetime.datetime.now()
                start_date = end_date - datetime.timedelta(days=validation_period)
                
                # Run backtest
                result = self.backtester.run_backtest(
                    strategy=strategy,
                    instrument="EUR/USD",
                    start_date=start_date,
                    end_date=end_date,
                    timeframe="H1",
                    initial_balance=10000.0,
                    risk_per_trade=risk_percent / 100
                )
                
                if result:
                    # Calculate confidence score based on backtest metrics
                    win_rate_factor = min(1.0, result.win_rate / 60) if result.win_rate > 0 else 0
                    profit_factor_factor = min(1.0, result.profit_factor / 1.5) if result.profit_factor > 0 else 0
                    sharpe_factor = min(1.0, result.sharpe_ratio / 1.0) if result.sharpe_ratio > 0 else 0
                    total_return_factor = min(1.0, result.total_return_pct / 5) if result.total_return_pct > 0 else 0
                    drawdown_factor = min(1.0, (30 - result.max_drawdown_pct) / 30) if result.max_drawdown_pct < 30 else 0
                    
                    # Calculate combined confidence (weighted average)
                    confidence = (
                        (win_rate_factor * 0.3) +
                        (profit_factor_factor * 0.2) +
                        (sharpe_factor * 0.2) +
                        (total_return_factor * 0.2) +
                        (drawdown_factor * 0.1)
                    )
                    
                    # Decide validity based on confidence threshold
                    valid = confidence >= MIN_CONFIDENCE_THRESHOLD
                    
                    if valid:
                        reason = f"Backtest validated with {confidence:.2f} confidence"
                    else:
                        reason = (
                            f"Confidence {confidence:.2f} below threshold {MIN_CONFIDENCE_THRESHOLD}. "
                            f"Win rate: {result.win_rate:.1f}%, Profit factor: {result.profit_factor:.2f}, "
                            f"Sharpe: {result.sharpe_ratio:.2f}, Drawdown: {result.max_drawdown_pct:.2f}%"
                        )
                
            except Exception as e:
                logger.error(f"Error during backtest validation: {e}")
                reason = f"Backtest error: {str(e)}"
            
            return {
                "valid": valid,
                "confidence": confidence,
                "reason": reason
            }
            
        except Exception as e:
            logger.error(f"Error validating trade: {e}")
            return {"valid": False, "confidence": 0.0, "reason": f"Validation error: {str(e)}"}
    
    def validate_strategy(self, strategy_details, price_data, risk_level=0.02, validation_period=30):
        """Validate a newly created strategy through backtesting"""
        try:
            # Extract strategy details
            name = strategy_details.get("name", "LLM Generated Strategy")
            description = strategy_details.get("description", "")
            parameters = strategy_details.get("parameters", {})
            code = strategy_details.get("code", "")
            
            # Create strategy
            strategy = LLMGeneratedStrategy(
                name=name,
                parameters=parameters,
                strategy_code=code
            )
            
            # Run backtest validation
            end_date = datetime.datetime.now()
            start_date = end_date - datetime.timedelta(days=validation_period)
            
            result = self.backtester.run_backtest(
                strategy=strategy,
                instrument="EUR/USD",
                start_date=start_date,
                end_date=end_date,
                timeframe="H1",
                initial_balance=10000.0,
                risk_per_trade=risk_level
            )
            
            if not result:
                return {"valid": False, "reason": "Strategy couldn't be backtested"}
            
            # Define validation criteria
            valid = (
                result.win_rate >= 50 and
                result.profit_factor >= 1.2 and
                result.sharpe_ratio >= 0.8 and
                result.max_drawdown_pct <= 20
            )
            
            if valid:
                # Save the strategy if valid
                self.memory.log_strategy(strategy)
                
                return {
                    "valid": True,
                    "reason": f"Strategy validated successfully with win rate {result.win_rate:.1f}%, profit factor {result.profit_factor:.2f}",
                    "metrics": {
                        "win_rate": result.win_rate,
                        "profit_factor": result.profit_factor,
                        "sharpe_ratio": result.sharpe_ratio,
                        "max_drawdown_pct": result.max_drawdown_pct,
                        "total_return_pct": result.total_return_pct
                    }
                }
            else:
                return {
                    "valid": False,
                    "reason": (
                        f"Strategy failed validation with win rate {result.win_rate:.1f}%, "
                        f"profit factor {result.profit_factor:.2f}, sharpe {result.sharpe_ratio:.2f}, "
                        f"drawdown {result.max_drawdown_pct:.2f}%"
                    ),
                    "metrics": {
                        "win_rate": result.win_rate,
                        "profit_factor": result.profit_factor,
                        "sharpe_ratio": result.sharpe_ratio,
                        "max_drawdown_pct": result.max_drawdown_pct,
                        "total_return_pct": result.total_return_pct
                    }
                }
                
        except Exception as e:
            logger.error(f"Error validating strategy: {e}")
            return {"valid": False, "reason": f"Validation error: {str(e)}"}
    
    def _create_validation_strategy(self, strategy_type, entry_price, stop_loss, direction):
        """Create a simple strategy for trade validation"""
        if strategy_type.lower() == "trend_following":
            strategy_code = """
def generate_signals(self, data):
    if data.empty:
        return data
    
    df = data.copy()
    
    # Calculate EMAs
    df['ema_20'] = df['close'].ewm(span=20, adjust=False).mean()
    df['ema_50'] = df['close'].ewm(span=50, adjust=False).mean()
    
    # Initialize signal column
    df['signal'] = 0
    
    # Generate signals based on direction for validation
    direction = self.parameters.get('direction', 'BUY')
    entry_price = self.parameters.get('entry_price', 0)
    
    if direction == 'BUY':
        # Buy when price is near entry and EMA20 > EMA50
        buy_condition = (df['close'] >= entry_price * 0.9995) & (df['close'] <= entry_price * 1.0005) & (df['ema_20'] > df['ema_50'])
        df.loc[buy_condition, 'signal'] = 1
    else:
        # Sell when price is near entry and EMA20 < EMA50
        sell_condition = (df['close'] >= entry_price * 0.9995) & (df['close'] <= entry_price * 1.0005) & (df['ema_20'] < df['ema_50'])
        df.loc[sell_condition, 'signal'] = -1
    
    return df
"""
        elif strategy_type.lower() == "breakout":
            strategy_code = """
def generate_signals(self, data):
    if data.empty:
        return data
    
    df = data.copy()
    
    # Calculate Bollinger Bands
    window = 20
    df['middle_band'] = df['close'].rolling(window=window).mean()
    df['std'] = df['close'].rolling(window=window).std()
    df['upper_band'] = df['middle_band'] + (df['std'] * 2)
    df['lower_band'] = df['middle_band'] - (df['std'] * 2)
    
    # Initialize signal column
    df['signal'] = 0
    
    # Generate signals based on direction for validation
    direction = self.parameters.get('direction', 'BUY')
    entry_price = self.parameters.get('entry_price', 0)
    
    if direction == 'BUY':
        # Buy when price breaks above upper band
        buy_condition = (df['close'] >= entry_price * 0.9995) & (df['close'] <= entry_price * 1.0005) & (df['close'] > df['upper_band'])
        df.loc[buy_condition, 'signal'] = 1
    else:
        # Sell when price breaks below lower band
        sell_condition = (df['close'] >= entry_price * 0.9995) & (df['close'] <= entry_price * 1.0005) & (df['close'] < df['lower_band'])
        df.loc[sell_condition, 'signal'] = -1
    
    return df
"""
        else:  # Default to mean_reversion
            strategy_code = """
def generate_signals(self, data):
    if data.empty:
        return data
    
    df = data.copy()
    
    # Calculate RSI
    delta = df['close'].diff()
    gain = delta.where(delta > 0, 0).rolling(window=14).mean()
    loss = -delta.where(delta < 0, 0).rolling(window=14).mean()
    rs = gain / loss
    df['rsi'] = 100 - (100 / (1 + rs))
    
    # Initialize signal column
    df['signal'] = 0
    
    # Generate signals based on direction for validation
    direction = self.parameters.get('direction', 'BUY')
    entry_price = self.parameters.get('entry_price', 0)
    
    if direction == 'BUY':
        # Buy when RSI is below 30 (oversold) and price at entry
        buy_condition = (df['close'] >= entry_price * 0.9995) & (df['close'] <= entry_price * 1.0005) & (df['rsi'] < 30)
        df.loc[buy_condition, 'signal'] = 1
    else:
        # Sell when RSI is above 70 (overbought) and price at entry
        sell_condition = (df['close'] >= entry_price * 0.9995) & (df['close'] <= entry_price * 1.0005) & (df['rsi'] > 70)
        df.loc[sell_condition, 'signal'] = -1
    
    return df
"""
        
        # Create strategy with proper parameters
        strategy = LLMGeneratedStrategy(
            name=f"Validation_{strategy_type}",
            parameters={
                "direction": direction,
                "entry_price": entry_price,
                "stop_loss": stop_loss
            },
            strategy_code=strategy_code
        )
        
        return strategy
    
    def review_and_evolve(self, account_status):
        """Periodically review performance and evolve strategies and prompts"""
        try:
            # Get memory metrics
            memory_stats = {
                "balance": account_status.get("balance", 0),
                "currency": "USD",
                "safety_level": self.memory.memory.get("safety_level", 0.01),
                "daily_profit_pct": account_status.get("daily_profit_pct", 0),
                "win_rate": (self.memory.memory.get("win_count", 0) / self.memory.memory.get("trade_count", 1)) * 100 if self.memory.memory.get("trade_count", 0) > 0 else 0,
                "win_count": self.memory.memory.get("win_count", 0),
                "trade_count": self.memory.memory.get("trade_count", 0),
                "strategy_weights": self.memory.memory.get("strategy_weights", {})
            }
            
            # Get recent trades
            recent_trades = self.memory.get_recent_trades(20)
            
            # Format recent trades for prompt
            recent_trades_formatted = []
            for trade in recent_trades:
                trade_str = f"Direction: {trade.get('direction', 'Unknown')}, "
                trade_str += f"Entry: {trade.get('entry_price', 'Unknown')}, "
                trade_str += f"Exit: {trade.get('exit_price', 'Unknown') if trade.get('exit_price') else 'Open'}, "
                trade_str += f"Result: {'Win' if trade.get('is_win') else 'Loss' if trade.get('is_loss') else 'Unknown/Open'}, "
                trade_str += f"Strategy: {trade.get('strategy', 'Unknown')}, "
                trade_str += f"Reasoning: {trade.get('reasoning', 'None provided')[:100]}..."
                recent_trades_formatted.append(trade_str)
            
            # Get saved strategies
            saved_strategies = self.memory.get_saved_strategies()
            
            # Format saved strategies
            saved_strategies_formatted = []
            for strategy in saved_strategies:
                strategy_str = f"Name: {strategy.get('name', 'Unknown')}, "
                strategy_str += f"Created: {strategy.get('timestamp', 'Unknown')}, "
                strategy_str += f"Parameters: {strategy.get('parameters', {})}"
                saved_strategies_formatted.append(strategy_str)
            
            # Create review prompt
            from prompts import SYSTEM_REVIEW_PROMPT
            prompt = SYSTEM_REVIEW_PROMPT.format(
                balance=memory_stats["balance"],
                currency="USD",
                daily_profit_pct=memory_stats["daily_profit_pct"],
                win_rate=memory_stats["win_rate"],
                win_count=memory_stats["win_count"],
                trade_count=memory_stats["trade_count"],
                safety_level=memory_stats["safety_level"],
                strategy_weights=memory_stats["strategy_weights"],
                system_prompt=self.system_prompt,
                recent_trades="\n".join(recent_trades_formatted),
                saved_strategies="\n".join(saved_strategies_formatted)
            )
            
            # Call OpenAI API for review
            response = openai.ChatCompletion.create(
                model="gpt-4-turbo-preview",  # Use appropriate model
                messages=[
                    {"role": "system", "content": "You are an AI that specializes in reviewing and improving forex trading systems."},
                    {"role": "user", "content": prompt}
                ],
                temperature=0.7,
                max_tokens=2000
            )
            
            # Parse response
            review_text = response.choices[0].message.content
            
            # Try to parse as JSON
            try:
                import json
                # Find JSON part
                json_start = review_text.find('{')
                json_end = review_text.rfind('}') + 1
                
                if json_start != -1 and json_end != -1:
                    json_str = review_text[json_start:json_end]
                    json_str = json_str.strip()
                    
                    try:
                        review_json = json.loads(json_str)
                    except json.JSONDecodeError:
                        # Try to fix common JSON formatting issues
                        json_str = json_str.replace(",\n}", "\n}")  # Fix trailing commas
                        json_str = json_str.replace(",\n  }", "\n  }")
                        review_json = json.loads(json_str)
                    
                    # Process strategy weights
                    if "strategy_weights" in review_json:
                        self.memory.memory["strategy_weights"] = review_json["strategy_weights"]
                    
                    # Process improved prompt
                    if "improved_prompt" in review_json:
                        new_prompt = review_json["improved_prompt"]
                        
                        # Log the prompt update
                        self.memory.log_review({
                            "prompt_version": new_prompt,
                            "reason": review_json.get("reasoning", "Periodic system review"),
                            "performance_analysis": review_json.get("performance_analysis", "")
                        })
                        
                        # Update the system prompt
                        self.system_prompt = new_prompt
                    
                    # Add raw response for reference
                    review_json["raw_review_text"] = review_text
                    
                    return review_json
                    
                else:
                    logger.warning("No JSON found in review response")
                    return {"error": "Invalid review format", "raw_review_text": review_text}
                    
            except Exception as e:
                logger.error(f"Error parsing review response: {e}")
                return {"error": f"Parsing error: {str(e)}", "raw_review_text": review_text}
                
        except Exception as e:
            logger.error(f"Error during system review: {e}")
            return {"error": f"Review error: {str(e)}"}