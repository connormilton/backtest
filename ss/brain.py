#!/usr/bin/env python3
"""
Trading Bot Brain Module
Contains the LLM integration and decision-making logic for the trading bot
"""

import os
import json
import logging
import datetime
import pandas as pd
import numpy as np
import openai
from typing import Dict, List, Any, Optional, Tuple, Union

# Configure logging
logger = logging.getLogger("Trading_Brain")

# --- LLM Generated Strategy ---
class LLMGeneratedStrategy:
    """Strategy dynamically generated by LLM with parameters"""
    
    def __init__(self, name="LLM Generated Strategy", parameters=None, strategy_code=None):
        """Initialize with strategy parameters and executable code"""
        super().__init__()
        self.name = name
        
        # Set default parameters
        self.parameters = parameters or {}
        
        # Store strategy code
        self.strategy_code = strategy_code or """
def generate_signals(self, data):
    # Default implementation - SMA Crossover
    if data.empty:
        return data
    
    # Make a copy to avoid modifying the original
    df = data.copy()
    
    # Calculate fast and slow SMAs
    fast_period = self.parameters.get('fast_period', 10)
    slow_period = self.parameters.get('slow_period', 30)
    
    df['fast_ma'] = df['close'].rolling(window=fast_period).mean()
    df['slow_ma'] = df['close'].rolling(window=slow_period).mean()
    
    # Initialize signal column
    df['signal'] = 0
    
    # Calculate crossover signals
    df['prev_fast_ma'] = df['fast_ma'].shift(1)
    df['prev_slow_ma'] = df['slow_ma'].shift(1)
    
    # Buy signal: fast MA crosses above slow MA
    buy_condition = (df['prev_fast_ma'] < df['prev_slow_ma']) & (df['fast_ma'] > df['slow_ma'])
    df.loc[buy_condition, 'signal'] = 1
    
    # Sell signal: fast MA crosses below slow MA
    sell_condition = (df['prev_fast_ma'] > df['prev_slow_ma']) & (df['fast_ma'] < df['slow_ma'])
    df.loc[sell_condition, 'signal'] = -1
    
    return df
"""
        
        # Create the function dynamically
        self._create_dynamic_method()
    
    def _create_dynamic_method(self):
        """Create generate_signals method dynamically from code string"""
        try:
            # Create a local namespace
            local_namespace = {}
            
            # Execute the code in the local namespace
            exec(self.strategy_code, globals(), local_namespace)
            
            # Bind the function to the instance
            self.generate_signals_impl = local_namespace.get('generate_signals')
            
            if not self.generate_signals_impl:
                logger.error("Strategy code did not define a generate_signals function")
                # Set default implementation
                self.generate_signals_impl = lambda self, data: data
                
        except Exception as e:
            logger.error(f"Error creating dynamic method: {str(e)}")
            # Set default implementation
            self.generate_signals_impl = lambda self, data: data
    
    def generate_signals(self, data):
        """Generate trading signals using dynamically created method"""
        try:
            # Call the dynamically created implementation
            return self.generate_signals_impl(self, data)
        except Exception as e:
            logger.error(f"Error in dynamic strategy: {str(e)}")
            # Return original data if there's an error
            return data
    
    def calculate_stop_loss(self, data, signal_row_idx, direction):
        """Calculate stop loss based on recent price action"""
        # Look back for recent swing points
        lookback = min(20, signal_row_idx)
        recent_data = data.iloc[signal_row_idx-lookback:signal_row_idx+1]
        
        if direction == "BUY":
            # For buy signals, set stop below recent low
            stop_price = recent_data['low'].min() * 0.998  # Slightly below the low
        else:
            # For sell signals, set stop above recent high
            stop_price = recent_data['high'].max() * 1.002  # Slightly above the high
            
        return stop_price
    
    def calculate_take_profit(self, data, signal_row_idx, direction):
        """Calculate take profit based on stop loss distance"""
        # Set take profit at 2:1 risk-reward ratio
        entry_price = data.iloc[signal_row_idx]['close']
        stop_loss = self.calculate_stop_loss(data, signal_row_idx, direction)
        
        if direction == "BUY":
            risk = entry_price - stop_loss
            take_profit = entry_price + (risk * 2)
        else:
            risk = stop_loss - entry_price
            take_profit = entry_price - (risk * 2)
            
        return take_profit
    
    def set_parameters(self, **kwargs):
        """Update strategy parameters"""
        self.parameters.update(kwargs)
    
    def save_to_file(self, filename=None):
        """Save strategy to file for later reuse"""
        if filename is None:
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            safe_name = self.name.replace(" ", "_").lower()
            filename = f"strategies/{safe_name}_{timestamp}.json"
        
        os.makedirs(os.path.dirname(filename), exist_ok=True)
        
        strategy_data = {
            "name": self.name,
            "parameters": self.parameters,
            "strategy_code": self.strategy_code
        }
        
        with open(filename, 'w') as f:
            json.dump(strategy_data, f, indent=2)
        
        logger.info(f"Strategy saved to {filename}")
        return filename
    
    @staticmethod
    def load_from_file(filename):
        """Load strategy from file"""
        with open(filename, 'r') as f:
            strategy_data = json.load(f)
        
        return LLMGeneratedStrategy(
            name=strategy_data.get("name", "Loaded Strategy"),
            parameters=strategy_data.get("parameters", {}),
            strategy_code=strategy_data.get("strategy_code", "")
        )

# --- Memory System ---
class TradingMemory:
    """Maintains trading history and system state"""
    
    def __init__(self):
        """Initialize trading memory"""
        self.memory_file = "data/system_memory.json"
        self.trade_log_file = "data/trade_log.jsonl"
        self.review_log_file = "data/review_log.jsonl"
        self.strategies_dir = "strategies"
        
        # Ensure data directories exist
        os.makedirs("data", exist_ok=True)
        os.makedirs(self.strategies_dir, exist_ok=True)
        
        # Initialize or load system memory
        self.load_memory()
    
    def load_memory(self):
        """Load or initialize system memory"""
        if os.path.exists(self.memory_file):
            try:
                with open(self.memory_file, "r") as f:
                    self.memory = json.load(f)
            except:
                self.initialize_memory()
        else:
            self.initialize_memory()
    
    def initialize_memory(self):
        """Create initial memory structure"""
        from bot import INITIAL_SAFETY_LEVEL
        
        self.memory = {
            "created": datetime.datetime.now().isoformat(),
            "last_updated": datetime.datetime.now().isoformat(),
            "trade_count": 0,
            "win_count": 0,
            "loss_count": 0,
            "safety_level": INITIAL_SAFETY_LEVEL,
            "daily_drawdown": 0.0,
            "daily_profit": 0.0,
            "daily_profit_pct": 0.0,
            "daily_high_balance": 0.0,
            "daily_starting_balance": 0.0,
            "total_risk_committed": 0.0,
            "prompt_versions": [],
            "strategy_weights": {
                "trend_following": 1.0,
                "breakout": 1.0,
                "mean_reversion": 1.0
            },
            "saved_strategies": []
        }
        self.save_memory()
    
    def save_memory(self):
        """Save system memory to disk"""
        self.memory["last_updated"] = datetime.datetime.now().isoformat()
        with open(self.memory_file, "w") as f:
            json.dump(self.memory, f, indent=2)
    
    def log_trade(self, trade_data):
        """Log a trade to the trade history"""
        from bot import INCREASE_FACTOR
        
        # Update trade count
        self.memory["trade_count"] += 1
        
        # Update win/loss stats if applicable
        if trade_data.get("is_win"):
            self.memory["win_count"] += 1
            # Increase safety level after win
            self.memory["safety_level"] = min(0.05, self.memory["safety_level"] + INCREASE_FACTOR)
        elif trade_data.get("is_loss"):
            self.memory["loss_count"] += 1
        
        # Add timestamp if not provided
        if "timestamp" not in trade_data:
            trade_data["timestamp"] = datetime.datetime.now().isoformat()
        
        # Append to trade log
        with open(self.trade_log_file, "a") as f:
            f.write(json.dumps(trade_data) + "\n")
        
        # Save updated memory
        self.save_memory()
    
    def log_review(self, review_data):
        """Log a system review"""
        # Save the new prompt version if provided
        if "prompt_version" in review_data:
            self.memory["prompt_versions"].append({
                "timestamp": datetime.datetime.now().isoformat(),
                "content": review_data["prompt_version"],
                "reason": review_data.get("reason", "Regular review")
            })
        
        # Update strategy weights if provided
        if "strategy_weights" in review_data:
            self.memory["strategy_weights"] = review_data["strategy_weights"]
        
        # Append to review log
        with open(self.review_log_file, "a") as f:
            f.write(json.dumps(review_data) + "\n")
        
        # Save updated memory
        self.save_memory()
    
    def log_strategy(self, strategy):
        """Save a successful strategy to memory"""
        # Save strategy to file
        filename = strategy.save_to_file()
        
        # Add to memory
        if "saved_strategies" not in self.memory:
            self.memory["saved_strategies"] = []
            
        self.memory["saved_strategies"].append({
            "name": strategy.name,
            "timestamp": datetime.datetime.now().isoformat(),
            "filename": filename,
            "parameters": strategy.parameters
        })
        
        # Save updated memory
        self.save_memory()
    
    def get_recent_trades(self, limit=10):
        """Get recent trades from log"""
        trades = []
        try:
            if os.path.exists(self.trade_log_file):
                with open(self.trade_log_file, "r") as f:
                    for line in f:
                        trades.append(json.loads(line))
                
                # Sort by timestamp (newest first) and limit
                trades.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
                return trades[:limit]
        except Exception as e:
            logger.error(f"Error getting recent trades: {e}")
        
        return trades
    
    def reset_daily_stats(self, account_balance):
        """Reset daily statistics"""
        self.memory["daily_drawdown"] = 0.0
        self.memory["daily_profit"] = 0.0
        self.memory["daily_profit_pct"] = 0.0
        self.memory["daily_high_balance"] = account_balance
        self.memory["daily_starting_balance"] = account_balance
        self.memory["total_risk_committed"] = 0.0
        self.save_memory()
    
    def get_saved_strategies(self, limit=5):
        """Get the most recent saved strategies"""
        if "saved_strategies" not in self.memory:
            return []
            
        strategies = self.memory["saved_strategies"]
        strategies.sort(key=lambda x: x.get("timestamp", ""), reverse=True)
        return strategies[:limit]
    
    def load_strategy(self, strategy_name=None, strategy_file=None):
        """Load a strategy from memory or file"""
        if strategy_file:
            return LLMGeneratedStrategy.load_from_file(strategy_file)
        
        if strategy_name:
            strategies = self.memory.get("saved_strategies", [])
            for strategy in strategies:
                if strategy.get("name") == strategy_name and os.path.exists(strategy.get("filename", "")):
                    return LLMGeneratedStrategy.load_from_file(strategy.get("filename"))
        
        # Return most recent if not found
        strategies = self.get_saved_strategies(1)
        if strategies:
            strategy = strategies[0]
            if os.path.exists(strategy.get("filename", "")):
                return LLMGeneratedStrategy.load_from_file(strategy.get("filename"))
        
        # Return default if no saved strategies
        return LLMGeneratedStrategy()

# --- LLM Trading Brain ---
class LLMTradingBrain:
    """LLM-powered trading decision maker with self-improvement capabilities"""
    
    def __init__(self, memory, backtester):
        """Initialize the LLM trading brain"""
        self.memory = memory
        self.backtester = backtester
        
        # Get API key from environment
        from bot import OPENAI_API_KEY
        openai.api_key = OPENAI_API_KEY
        
        # Initial system prompt (will be evolved over time)
        self.system_prompt = """
You are a self-evolving forex trading AI specializing in EUR/USD.

Your goal is to achieve a 5% daily return while respecting strict risk management:
- Maximum account risk: 10%
- Maximum daily drawdown: 10%